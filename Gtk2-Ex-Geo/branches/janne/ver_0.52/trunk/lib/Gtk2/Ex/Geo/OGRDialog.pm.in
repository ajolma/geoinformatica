package Gtk2::Ex::Geo::OGRDialog;

use strict;
use warnings;

use File::Spec;

BEGIN {
    if ($^O eq 'MSWin32') {
	require Win32::OLE;
	import Win32::OLE qw(in);
    }
}

require Exporter;

our @ISA = qw(Exporter Gtk2::Ex::Geo::DialogMaster);

use vars qw( %RENDER_AS2INDEX %INDEX2RENDER_AS );

our %EXPORT_TAGS = ( 'all' => [ qw(
	
) ] );

our @EXPORT_OK = ( @{ $EXPORT_TAGS{'all'} } );

our @EXPORT = qw(
	
);

%RENDER_AS2INDEX = (Native => 0, Points => 1, Lines => 2, Polygons => 3);
for (keys %RENDER_AS2INDEX) {
    $INDEX2RENDER_AS{$RENDER_AS2INDEX{$_}} = $_;
}

=pod

=head1 NAME

Gtk2::Ex::Geo::OGRDialog - Dialogs for vector (ogr) layers

=head1 SYNOPSIS

  use Gtk2::Ex::Geo::OGRDialog;

=head1 DESCRIPTION

=head2 EXPORT

None by default.

=head1 METHODS

=head2 new

=cut

sub new {
    my($class, %params) = @_;

    my @buffer = <DATA>;
    pop @buffer unless $buffer[$#buffer] =~ /^\</; # remove the extra content

    my $self = Gtk2::Ex::Geo::DialogMaster::new($class, %params, buffer => \@buffer);

    bless $self => (ref($class) or $class);
   
    bootstrap($self);    
    
    return $self;
}

sub bootstrap {
    my($self, $widget) = @_;

    $self->{glade} = Gtk2::GladeXML->new_from_buffer("@{$self->{buffer}}");
    
    for ('open_dialog',
	 'rasterize_dialog',
	 '2features_dialog') {
	$self->hide_on_delete($_);
    }

    $self->widget('open_dialog')->signal_connect(response => \&ogr_open_response, $self);
    $self->widget('rasterize_dialog')->signal_connect(response => \&rasterize_response, $self);

    my $combo = $self->widget('datasource_comboboxentry');
    my $model = Gtk2::ListStore->new('Glib::String');
    $combo->set_model($model);
    $combo->set_text_column(0);
    $model = $combo->get_model;
    $model->clear;

    $model->set ($model->append, 0, '');
    for my $datasource (sort keys %{$self->{resources}->{datasources}}) {
	$model->set ($model->append, 0, $datasource);
    }
    $combo->set_active(0);
    #$combo->signal_connect(changed => \&ds_changed, $self);

    my $button = $self->widget('delete_datasource_button');
    $button->signal_connect(clicked => \&delete_datasource, $self);
    $button = $self->widget('connect_datasource_button');
    $button->signal_connect(clicked => \&connect_datasource, $self);

    $self->{dir_model} = Gtk2::TreeStore->new(qw/Glib::String/);
    my $tv = $self->widget('dir_tv');
    $tv->set_model($self->{dir_model});
    my @columns = qw /dir/;
    my $i = 0;
    foreach my $column (@columns) {
	my $cell = Gtk2::CellRendererText->new;
	my $col = Gtk2::TreeViewColumn->new_with_attributes($column, $cell, text => $i++);
	$tv->append_column($col);
    }
    $tv->signal_connect(button_press_event => \&open_dir_tv_button_press, $self);
    $tv->signal_connect(key_press_event => \&open_dir_tv_key_press, $self);

    $self->{layer_model} = Gtk2::TreeStore->new(qw/Glib::String Glib::String/);
    $tv = $self->widget('layer_tv');
    $tv->set_model($self->{layer_model});
    $tv->get_selection->set_mode('multiple');
    @columns = qw /layer geom/;
    $i = 0;
    foreach my $column (@columns) {
	my $cell = Gtk2::CellRendererText->new;
	my $col = Gtk2::TreeViewColumn->new_with_attributes($column, $cell, text => $i++);
	$tv->append_column($col);
    }
    $tv->signal_connect(cursor_changed => \&on_layer_tv_cursor_changed, $self);

    $self->{property_model} = Gtk2::TreeStore->new(qw/Glib::String Glib::String/);
    $tv = $self->widget('property_tv');
    $tv->set_model($self->{property_model});
    @columns = qw /property value/;
    $i = 0;
    foreach my $column (@columns) {
	my $cell = Gtk2::CellRendererText->new;
	my $col = Gtk2::TreeViewColumn->new_with_attributes($column, $cell, text => $i++);
	$tv->append_column($col);
    }

    $self->{schema_model} = Gtk2::TreeStore->new(qw/Glib::String Glib::String/);
    $tv = $self->widget('schema_tv');
    $tv->set_model($self->{schema_model});
    @columns = qw /field type/;
    $i = 0;
    foreach my $column (@columns) {
	my $cell = Gtk2::CellRendererText->new;
	my $col = Gtk2::TreeViewColumn->new_with_attributes($column, $cell, text => $i++);
	$tv->append_column($col);
    }

    $self->{in_dir_tb} = [];

    my $entry = $self->widget('SQL_entry');
    $entry->signal_connect(key_press_event => \&edit_entry, [$self, $entry, 'SQL']);
    $entry->signal_connect(changed => \&on_SQL_entry_changed, $self);

    # features dialog for "features" vector layers
    my $fdialog = $self->widget('2features_dialog');
    $self->hide_on_click('2features_dialog', '2close-button');

    $tv = $self->widget('2feature_treeview');

    my $select = $tv->get_selection;
    $select->set_mode('multiple');
    $select->signal_connect(changed => \&feature_activated2, [$self, $self->widget('attributes_treeview')]);

    $self->widget('spinbutton3')->signal_connect
	(value_changed => \&fill_ftv2, [$self, $tv]);
    $self->widget('spinbutton4')->signal_connect
	(value_changed => \&fill_ftv2, [$self, $tv]);

    $self->widget('2zoom-to-button')->
	signal_connect(clicked => \&zoom_to_selected_features, 
		       [$self, $tv, '2features_dialog']);
 
    $self->prepare_simple_combo('like_combobox');
    $self->prepare_simple_combo('rasterize_value_comboboxentry');

    return $self->widget($widget) if $widget;
}


##################
#
#   features_dialog for a layer of features (not ogr layer)
#
##################


sub browse_features2 {
    my($self, $layer) = @_;

    my $dialog = $self->open_dialog('2features_dialog', 'Features of', $layer, 1);

    my @columns;
    my @coltypes;

    push @columns, 'index';
    push @coltypes, 'Glib::Int';

    my $tv = $self->widget('2feature_treeview');

    my $model = Gtk2::TreeStore->new(@coltypes);
    $tv->set_model($model);

    my @c = $tv->get_columns;
    for (@c) {
	$tv->remove_column($_);
    }

    my $i = 0;
    foreach my $column (@columns) {
	my $cell = Gtk2::CellRendererText->new;
	my $col = Gtk2::TreeViewColumn->new_with_attributes($column, $cell, text => $i++);
	$tv->append_column($col);
    }

    @c = $tv->get_columns;
    for (@c) {
	$_->set_clickable(1);
	$_->signal_connect(clicked => sub {
	    shift;
	    my($self, $tv, $layer) = @{$_[0]};
	    fill_ftv2(undef, [$self, $tv, $layer]);
	}, [$self, $tv, $layer]);
    }

    fill_ftv2(undef, [$self, $tv, $layer]);

    $tv = $self->widget('attributes_treeview');

    @columns = ('Field', 'Value');
    @coltypes = ('Glib::String', 'Glib::String');

    $model = Gtk2::TreeStore->new(@coltypes);
    $tv->set_model($model);

    @c = $tv->get_columns;
    for (@c) {
	$tv->remove_column($_);
    }

    $i = 0;
    foreach my $column (@columns) {
	my $cell = Gtk2::CellRendererText->new;
	my $col = Gtk2::TreeViewColumn->new_with_attributes($column, $cell, text => $i++);
	$tv->append_column($col);
    }

    $dialog->show_all;
    
}

sub fill_ftv2 {
    shift;
    my($self, $tv) = @{$_[0]};

    my $overlay = $self->{overlay};
    my $layer = $self->{dialogs}{'2features_dialog'}{layer};

    return unless $layer;
    return unless $overlay->has_layer($layer);

    my $from = $self->widget('spinbutton3')->get_value_as_int;
    my $count = $self->widget('spinbutton4')->get_value_as_int;

    my $model = $tv->get_model;

    $model->clear;

    my @recs;
    my $i = 1;
    my $k = 0;
    while ($i < $from+$count) {
	my $f = $layer->{features}->[$k++];
	$i++;
	next if $i <= $from;
	last unless $f;
	my @rec;
	my $rec = 0;

	push @rec,$rec++;
	push @rec,$k-1; # $f->GetFID;
	
	push @recs,\@rec;
    }
    $k = @recs;

    for my $rec (@recs) {
	
	my $iter = $model->insert (undef, 999999);
	$model->set ($iter, @$rec);
	
    }
    
}

sub feature_activated2 {
    my $selection = shift;
    my($self, $treeview) = @{$_[0]};
    my $layer = $self->{dialogs}{'2features_dialog'}{layer};

    my $ids = $self->get_selected_features($layer, $selection);
    my $features = $layer->features(with_id=>[keys %$ids]);
    return unless $features;
    return unless @$features;

    if (@$features == 1) {
	my @k = keys %$ids;
	my $f = $features->[0];
	my $schema = $layer->schema($k[0]);
	my $model = $treeview->get_model;
	$model->clear;

	my @recs;
	for my $name (sort {$schema->{$a}{Number} <=> $schema->{$b}{Number}} keys %$schema) {
	    next if $name eq 'FID';
	    my @rec;
	    my $rec = 0;
	    push @rec, $rec++;
	    push @rec, $name;
	    push @rec, $rec++;
	    push @rec, $f->GetField($name);
	    push @recs,\@rec;
	}

	for my $rec (@recs) {
	
	    my $iter = $model->insert (undef, 999999);
	    $model->set ($iter, @$rec);
	    
	}
	
    }

    my $overlay = $self->{overlay};

    $overlay->create_backup_pixmap;
    $overlay->restore_pixmap;

    my $gc = Gtk2::Gdk::GC->new($overlay->{pixmap});
    $gc->set_rgb_fg_color(Gtk2::Gdk::Color->new(65535,0,0));

    for my $f (@$features) {

	next unless $f; # should not happen

	my $geom = $f->GetGeometryRef();
	next unless $geom;

	$overlay->render_geometry($gc, $geom);
	
    }

    $overlay->update_image;

}

#
# these are common to both features dialog boxes:
#

sub get_selected_features {
    my($self, $layer, $selection) = @_;
    my @sel = $selection->get_selected_rows;
    my %sel;
    for (@sel) {
	$sel{$_->to_string} = 1;
    }
    
    my $tv = $selection->get_tree_view;;
    my $model = $tv->get_model;
    my $iter = $model->get_iter_first();
    my $i = 0;
    my %s;
    while ($iter) {
	my($id) = $model->get($iter, 0);
	$s{$id} = 1 if $sel{$i++};
	$iter = $model->iter_next($iter);
    }
    return \%s;
}

sub set_selected_features {
    my($self, $layer, $treeview) = @_;
    my $selected = $layer->selected_features();
    my $selection = $treeview->get_selection;
    my $model = $treeview->get_model;
    my $iter = $model->get_iter_first();
    while ($iter) {
	my($id) = $model->get($iter, 0);
	#print STDERR "select $id\n";
	$selection->select_iter($iter) if $selected->{$id};
	$iter = $model->iter_next($iter);
    }
}

=pod

=head2 open_dialog

=head3 ogr_open

=cut

##################
#
#   open_dialog
#
##################

sub ogr_open {
    my($self, $glue) = @_;

    $self->{history} = $glue->{history};

    $self->{path} = File::Spec->rel2abs('.') unless $self->{path};

    $self->fill_dir_tv();
    $self->fill_layer_tv();

    $self->{property_model}->clear;
    $self->{schema_model}->clear;

    my $dialog = $self->open_dialog('open_dialog', 'Open vector layer');
    $self->widget('update_checkbutton')->set_active(0);

    $dialog->show_all;

}

sub ogr_open_response {
    my($dialog, $response, $self) = @_;

    my $sql = $self->widget('SQL_entry')->get_text;
    $sql =~ s/^\s+//;
    $sql =~ s/\s+$//;
    $self->{history}->editing($sql);
    
    my $datasource = $self->widget('datasource_comboboxentry')->child->get_text;
    $datasource = $self->get_current_folder() unless $datasource;
    
    my($path, $focus_column) = $self->widget('layer_tv')->get_cursor;
    my $index = $path->to_string if $path;
    my $layer_name = $self->{layers}->[$index] if defined $index;

    my @ret;

    if ($response eq 'ok') {
	
	if ($sql) {
	    $self->{history}->enter();
	    $self->widget('SQL_entry')->set_text('');
	}
	
	my $layer_name_wish = $self->widget('layer_name_entry')->get_text;
	my $update = $self->widget('update_checkbutton')->get_active;
	
	my $selection = $self->widget('layer_tv')->get_selection;
	my @selected = $selection->get_selected_rows if $selection;
	if (@selected > 1) {
	    my @layers;
	    for my $selected (@selected) {
		    my $at = $selected->to_string;
		    push @layers, $self->{layers}->[$at];
		}
	    $layer_name = \@layers;
	}
	
	@ret = ($datasource,$layer_name,$layer_name_wish,$sql,$update);
	
    } elsif ($response eq '2') { # schema

	eval {
	    $self->fill_property_and_schema_tvs();
	};
	$self->message("$@ Is the SQL statement correct?") if $@;

	return;
	
    } elsif ($response eq '3') { # delete
	
	next unless defined $index;
	eval {
	    my $ds = Geo::OGR::Open($datasource, 1);
	    for my $i (0..$ds->GetLayerCount-1) {
		my $l = $ds->GetLayerByIndex($i);
		$ds->DeleteLayer($i), last if $l->GetName() eq $layer_name;
	    }
	};
	$self->message("$@") if $@;
	
	return;
	
    }

    $self->close_dialog([$self, 'open_dialog']);

    $self->{history}->enter(''); # the main window uses the same history

    $self->{glue}->add_vector(@ret) if @ret;

}

sub on_SQL_entry_changed {
    my($e,$self) = @_;
    my $sql = $self->widget('SQL_entry')->get_text;
    $sql =~ s/^\s+//;
    $sql =~ s/\s+$//;
    $self->widget('layer_name_entry')->set_text('SQL') if $sql;
}

sub on_layer_tv_cursor_changed {
    my($e,$self) = @_;
    my($path, $focus_column) = $self->widget('layer_tv')->get_cursor;
    my $index = $path->to_string if $path;
    my $layer_name = defined $index ? $self->{layers}->[$index] : '';
    $self->widget('layer_name_entry')->set_text($layer_name);
    $self->{history}->editing('');
    $self->widget('SQL_entry')->set_text('');
}

sub delete_datasource {
    my($button, $self) = @_;
    my $combo = $self->widget('datasource_comboboxentry');
    my $datasource = $combo->child->get_text;
    my $active = $combo->get_active();
    return if $active < 0;
    my $model = $combo->get_model;
    my $iter = $model->get_iter_from_string($active);
    $model->remove($iter);
    delete $self->{resources}->{datasources}->{$datasource};
    $combo->set_active(0);
}

sub connect_datasource {
    my($button, $self) = @_;
    my $datasource = $self->widget('datasource_comboboxentry')->child->get_text;
    $self->fill_layer_tv($datasource);
    if (@{$self->{layers}}) {
	unless ($self->{resources}->{datasources}->{$datasource}) {
	    my $combo = $self->widget('datasource_comboboxentry');
	    my $model = $combo->get_model;
	    $model->set ($model->append, 0, $datasource);
	    $self->{resources}->{datasources}->{$datasource} = 1;
	}
    } else {
	$self->message("No layers found in data source\n'$datasource'.");
	$self->fill_dir_tv;
    }
}

=pod

=head3 get_current_folder

=cut

sub get_current_folder {
    my $self = shift;
    return $self->{path};
}

=pod

=head3 fill_dir_tv

=cut

sub open_dir_tv_button_press {
    my($tv,$event,$self) = @_;
    if ($event->type =~ /^2button/) {
	$self->select_dir($tv);
    }
    return 0;
}

sub open_dir_tv_key_press {
    my($tv,$event,$self) = @_;
    if ($event->keyval == $Gtk2::Gdk::Keysyms{Return}) {
	$self->select_dir($tv);
    }
    return 0;
}

sub select_dir {
    my($self, $tv) = @_;
    my($path, $focus_column) = $tv->get_cursor;
    my $index = $path->to_string if $path;
    if (defined $index) {
	my $directory;
	if ($self->{path} eq '') {
	    $self->{volume} = $self->{dir_list}->[$index];
	    $directory = File::Spec->rootdir();
	} else {
	    my @directories;
	    for (reverse @{$self->{in_dir_tb}}) {
		push @directories, $_->get_label;
	    }
	    if ($^O eq 'MSWin32') {
		shift @directories; # remove volume
	    }
	    if ($self->{dir_list}->[$index] eq File::Spec->updir) {
		pop @directories;
	    } else {
		push @directories, $self->{dir_list}->[$index];
	    }
	    $directory = File::Spec->catdir(@directories);
	}
	$self->{path} = File::Spec->catpath($self->{volume}, $directory, '');
	$self->fill_dir_tv();
	$self->fill_layer_tv();
    }
}

sub fill_dir_tv {
    my $self = shift;

    $self->{dir_model}->clear;

    my $tb = $self->widget('dir_tb');

    for (@{$self->{in_dir_tb}}) {$tb->remove($_);}
    $self->{in_dir_tb} = [];

    my $sub = sub {
	my $n = $_[0]->get_label;
	my $self = $_[1];
	if ($n eq $self->{volume}) {
	    $self->{path} = '';
	} else {
	    my @directories;
	    for (reverse @{$self->{in_dir_tb}}) {
		push @directories, $_->get_label;
		last if $_ == $_[0];
	    }
	    if ($^O eq 'MSWin32') {
		shift @directories; # remove volume
	    }
	    my $directory = File::Spec->catdir(@directories);
	    $self->{path} = File::Spec->catpath($self->{volume}, $directory, '');
	}
	$self->fill_dir_tv();
	$self->fill_layer_tv();
    };

    if ($self->{path} eq '') {
	@{$self->{dir_list}} = ();
	my @d;

	my $fso = Win32::OLE->new('Scripting.FileSystemObject');
	for ( in $fso->Drives ) {
	    push @d, $_->{DriveLetter}.':';
	}

	for (@d) {
	    s/\\$//;
	    push @{$self->{dir_list}},$_;
	}
	@{$self->{dir_list}} = reverse @{$self->{dir_list}} if $self->{dir_list};
	for my $i (0..$#{$self->{dir_list}}) {
	    my $iter = $self->{dir_model}->insert (undef, 0);
	    $self->{dir_model}->set ($iter, 0, $self->{dir_list}->[$i] );
	}
	$self->widget('dir_tv')->set_cursor(Gtk2::TreePath->new(0));
	@{$self->{dir_list}} = reverse @{$self->{dir_list}} if $self->{dir_list};
	return;
    }

    my($volume,$directories,$file) = File::Spec->splitpath($self->{path}, 1);
    $self->{volume} = $volume;
    my @dirs = File::Spec->splitdir($directories);
    unshift @dirs, File::Spec->rootdir();
    if ($^O eq 'MSWin32') {
	unshift @dirs, $volume;
    }
    
    for (reverse @dirs) {
	next if /^\s*$/;
	my $b = Gtk2::ToolButton->new(undef,$_);
	$b->signal_connect("clicked", $sub, $self);
	$b->show;
	$tb->insert($b,0);
	push @{$self->{in_dir_tb}}, $b;
    }
    
    @{$self->{dir_list}} = ();
    if (opendir(DIR, $self->{path})) {
	
	my @files = sort {$b cmp $a} readdir(DIR);
	closedir DIR;

	for (@files) {
	    my $test = File::Spec->catpath( $volume, $directories, $_ );
	    next if /^\./ and not $_ eq File::Spec->updir;
	    next unless -d $test;
	    next if $_ eq File::Spec->curdir;
	    push @{$self->{dir_list}}, $_;
	}
	
	for my $i (0..$#{$self->{dir_list}}) {
	    my $iter = $self->{dir_model}->insert (undef, 0);
	    $self->{dir_model}->set ($iter, 0, $self->{dir_list}->[$i] );
	}

	$self->widget('dir_tv')->set_cursor(Gtk2::TreePath->new(0));

    }
    @{$self->{dir_list}} = reverse @{$self->{dir_list}} if $self->{dir_list};
}

=pod

=head3 fill_layer_tv

=cut

sub fill_layer_tv {
    my($self, $datasource) = @_;

    $self->{layer_model}->clear;
    $self->{property_model}->clear;
    $self->{schema_model}->clear;
    $self->widget('schema_label')->set_label('');

    @{$self->{layers}} = ();

    $datasource = $self->{path} unless $datasource;

    return unless $datasource;

    $self->{vector} = new Geo::Vector( datasource => $datasource );
    my $layers = $self->{vector}->layers();
    @{$self->{layers}} = sort {$b cmp $a} keys %$layers;

    for my $name (@{$self->{layers}}) {
	my $iter = $self->{layer_model}->insert (undef, 0);
	$self->{layer_model}->set ($iter, 0, $name, 1, $layers->{$name});
    }
    $self->widget('layer_tv')->set_cursor(Gtk2::TreePath->new(0));
	
    @{$self->{layers}} = reverse @{$self->{layers}};

    on_layer_tv_cursor_changed(undef, $self);
}

=pod

=head3 fill_property_and_schema_tvs

=cut

sub fill_property_and_schema_tvs {
    my $self = shift;

    $self->{property_model}->clear;
    $self->{schema_model}->clear;

    my $label = '';

    my $layer;

    my $sql = $self->widget('SQL_entry')->get_text;

    if ($sql) {

	$layer = $self->{vector}->layer( sql => $sql );
	$label = 'Schema of the SQL query' if $layer;

    } else {

	my ($path, $focus_column) = $self->widget('layer_tv')->get_cursor;
	if ($path) {
	    my $index = $path->to_string;
	    if (defined $index) {
		my $name = $self->{layers}->[$index];
		$layer = $self->{vector}->layer( layer => $name );
		$label = "Schema of $name" if $layer;
	    }
	}

    }

    $self->widget('schema_label')->set_label($label);

    return unless $layer;
 
    my $iter = $self->{property_model}->insert (undef, 0);
    $self->{property_model}->set ($iter,
				  0, 'Features',
				  1, $layer->feature_count()
				  );

    my @world = $layer->world;
    $iter = $self->{property_model}->insert (undef, 0);
    $self->{property_model}->set ($iter,
				  0, 'Bounding box',
				  1, "minX = $world[0], minY = $world[1], maxX = $world[2], maxY = $world[3]"
				  );

    $iter = $self->{property_model}->insert (undef, 0);
    my $srs = $layer->srs(format=>'Wkt');
    $srs = 'undefined' unless $srs;
    $self->{property_model}->set ($iter,
				  0, 'SpatialRef',
				  1, $srs
				  );
	
    my $schema = $layer->schema();
    for my $name (sort {$b cmp $a} keys %$schema) {
	my $iter = $self->{schema_model}->insert (undef, 0);
	$self->{schema_model}->set ($iter,
				    0, $name,
				    1, $schema->{$name}{TypeName}
				    );
    }
    
}

=pod

=head3 edit_entry

=cut

sub edit_entry {
    my($e,$event,$data) = @_;
    my($self, $entry, $name) = @$data;

    my $key = $event->keyval;

    if ($key == $Gtk2::Gdk::Keysyms{Up}) {
	$entry->set_text($self->{history}->arrow_up);
	return 1;
    } elsif ($key == $Gtk2::Gdk::Keysyms{Down}) {
	$entry->set_text($self->{history}->arrow_down);
	return 1;
    }

}

=pod

=head2 rasterize_dialog

=cut

##################
#
#   rasterize_dialog
#
##################

sub rasterize_dialog {
    my($self, $layer) = @_;

    my $dialog = $self->open_dialog('rasterize_dialog', 'Rasterize', $layer);

    $self->{rasterize_layer} = $layer;

    $self->widget('rasterize_name_entry')->set_text('r');

    # fill like_combobox: all available rasters

    my $combo = $self->widget('like_combobox');
    my $model = $combo->get_model;
    $model->clear;

    $self->{rasters} = [];
    push @{$self->{rasters}}, $self->{overlay};
    $model->set ($model->append, 0, "Use current view");
    for my $layer (@{$self->{overlay}->{layers}}) {
	next unless ref($layer) eq 'Geo::Raster';
	push @{$self->{rasters}}, $layer;
	$model->set ($model->append, 0, $layer->name);
    }
    $combo->set_active(0);

    #$self->prepare_render_as_combo('rasterize_render_as_combobox', $layer);
    $combo = $self->widget('rasterize_render_as_combobox');
    $model = $combo->get_model;
    $model->clear;
    for (sort {$Geo::Vector::RENDER_AS{$a} <=> $Geo::Vector::RENDER_AS{$b}} keys %Geo::Vector::RENDER_AS) {
	$model->set ($model->append, 0, $_);
    }
    my $a = 0;
    $a = $layer->render_as;
    $a = $Geo::Vector::RENDER_AS{$a} if defined $a;
    $combo->set_active($a);

    # fill rasterize_value_comboboxentry: int and float fields
    $combo = $self->widget('rasterize_value_comboboxentry');
    $model = $combo->get_model;
    $model->clear;

    $self->{fields} = [''];
    $model->set ($model->append, 0, 'Draw with value 1');
    my $schema = $layer->{ogr_layer}->GetLayerDefn();
    for my $i (0..$schema->GetFieldCount-1) {
	my $column = $schema->GetFieldDefn($i);
	my $type = $column->GetFieldTypeName($column->GetType);
	if ($type eq 'Integer' or $type eq 'Real') {
	    push @{$self->{fields}}, $column->GetName;
	    $model->set($model->append, 0, $column->GetName);
	}
    }
    $combo->set_active(0);

    $self->widget('rasterize_nodata_value_entry')->set_text(-9999);

}

sub rasterize_response {
    my($dialog, $response, $self) = @_;

    my %ret;
 
    if ($response eq 'ok') {

	my %ret;
	$ret{name} = $self->widget('rasterize_name_entry')->get_text();
	$ret{like} = $self->{rasters}[$self->widget('like_combobox')->get_active];
	$ret{render_as} = $self->widget('rasterize_render_as_combobox')->get_active;
	$ret{render_as} = $INDEX2RENDER_AS{$ret{render_as}};
	$ret{feature} = $self->widget('rasterize_fid_entry')->get_text;
	$ret{feature} = -1 unless $ret{feature} =~ /^\d+$/;
	$ret{value_field} = $self->widget('rasterize_value_comboboxentry')->get_active;
	$ret{value_field} = $self->{fields}[$ret{value_field}];
	$ret{nodata_value} = $self->widget('rasterize_nodata_value_entry')->get_text();

	my $g = $self->{rasterize_layer}->rasterize(%ret);
	if ($g) {
	    $self->{glue}->add_layer($g, $ret{name}, 1);
	    $self->{glue}->{overlay}->render;
	}

    } elsif ($response eq 'cancel') {

    }

    delete $self->{rasterize_layer};
    delete $self->{rasters};
    delete $self->{fields};

    $self->close_dialog([$self, 'rasterize_dialog']);

}

sub min {
    $_[0] > $_[1] ? $_[1] : $_[0];
}

sub max {
    $_[0] > $_[1] ? $_[0] : $_[1];
}

1;

=pod

=head1 SEE ALSO

Gtk2::Ex::Geo

=head1 AUTHOR

Ari Jolma, E<lt>ajolma at tkk.fiE<gt>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2006 by Ari Jolma

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.5 or,
at your option, any later version of Perl 5 you may have available.

=cut

__DATA__
