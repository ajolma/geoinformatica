package Gtk2::Ex::Geo::Glue;

#use strict; # causes "Variable not imported in some cases" ??
use warnings;
use UNIVERSAL qw(isa);
use Carp;
use File::Spec;
use File::Basename;
use Term::ReadLine;

use Gtk2::Ex::Geo::TreeDumper;

#use Data::TreeDumper::Renderer::GTK;

BEGIN {
    use Exporter "import";
    our @ISA = qw(Exporter Gtk2::Ex::Geo::DialogMaster);
    our @EXPORT = qw();
    our @EXPORT_OK = qw();
    our %EXPORT_TAGS = ( FIELDS => [ @EXPORT_OK, @EXPORT ] );
}

# Preloaded methods go here.

# Autoload methods go after =cut, and are processed by the autosplit program.

=pod

=head1 NAME

Gtk2::Ex::Geo::Glue - Module for glueing widgets into a GIS.

=head1 METHODS

=head2 new

    $gis = new Gtk2::Ex::Geo::Glue ($history=>"filename", $resources=>"filename");

Creates toolbar, entry, model, tree_view and overlay widgets and
stores them into the object.

=cut

sub new {
    my $class = shift;
    my %opt = @_;

    my @columns = qw /name type ? a/;
    
    my $model = Gtk2::TreeStore->new(qw/Glib::String Glib::String Glib::String Glib::String/);

    my $tree_view = Gtk2::TreeView->new($model);

    my $i = 0;
    foreach my $column (@columns) {
	my $cell = Gtk2::CellRendererText->new;
	my $col = Gtk2::TreeViewColumn->new_with_attributes($column, $cell, text => $i++);
	$tree_view->append_column($col);
    }

    my $overlay = Gtk2::Ex::Geo::Overlay->new();
    $overlay->my_inits();

    my $self = { model => $model,
		 main_window => $opt{main_window},
		 tree_view => $tree_view,
		 overlay => $overlay,
	     };

    $tree_view->signal_connect
	( cursor_changed => 
	  sub {
	      my(undef, $gis) = @_;
	      $gis->get_selected_layer();
	  }, $self);

    $overlay->signal_connect
	( features_selected => 
	  sub {
	      my(undef, $gis) = @_;
	      my $layer = $gis->get_selected_layer();
	      #$gis->{vector_dialogs}->features_dialog($layer);
	      $layer->open_features_dialog($gis);
	  }, $self);

    if ($opt{history}) {
	if (open TMP, $opt{history}) {
	    my @history = <TMP>;
	    CORE::close TMP;
	    for (@history) {
		chomp $_;
		s/\r//;
	    }
	    $self->{history} = new Gtk2::Ex::Geo::History(\@history);
	} else {
	    carp("$!: $opt{history} (it will be created at exit)");
	}
	$self->{history_file} = $opt{history};
    }
    $self->{history} = new Gtk2::Ex::Geo::History(['']) unless $self->{history};
    if ($opt{resources}) {
	if (open TMP, $opt{resources}) {
	    my $key = '';
	    while (<TMP>) {
		chomp $_;
		s/\r//;
		if (/^  /) {
		    s/^  //;
		    $self->{resources}{$key}{$_} = 1;
		} else {
		    $key = $_;
		}
	    }
	    CORE::close TMP;
	} else {
	    carp("$!: $opt{resources} (it will be created at exit)");
	}
	$self->{resources_file} = $opt{resources};
    }

    @{$self->{buffer}} = <Gtk2::Ex::Geo::History::DATA>;
    pop @{$self->{buffer}} unless $self->{buffer}[$#{$self->{buffer}}] =~ /^\</; # remove the extra content
    shift @{$self->{buffer}} if $self->{buffer}[0] =~ /^\s*$/;
    $self->{glade} = Gtk2::GladeXML->new_from_buffer("@{$self->{buffer}}");

    $tree_view->signal_connect(button_press_event => \&layer_menu, $self);

    $overlay->set_event_handler(\&event_handler,$self);
    $overlay->set_draw_on(\&draw_on,$self);

    $self->{toolbar} = toolbar($self);

    $self->{statusbar} = Gtk2::Statusbar->new();

    $self->{vector_dialogs} = Gtk2::Ex::Geo::OGRDialog
	->new(%$self, glue=>$self, overlay => $overlay, main_window => $self->{main_window});

    $self->{raster_dialogs} = Gtk2::Ex::Geo::GDALDialog
	->new(glue=>$self, overlay => $overlay, main_window => $self->{main_window});

    $self->{entry} = Gtk2::Entry->new();

    $self->{entry}->signal_connect(key_press_event => \&eval_entry, $self);

    set_event_handler($self, \&default_event_handler, $self);

    bless($self, $class); 

    $self->hide_on_delete('dialog1');
    $self->hide_on_click('dialog1', 'closebutton1');

    return $self;
}

sub close {
    my($self) = @_;
    if ($self->{history_file}) {
	my $history = $self->{history}->{history};
	if (open TMP,">$self->{history_file}") {
	    for (@$history[max(0,$#$history-1000)..$#$history]) {
		print TMP "$_\n";
	    }
	    close TMP;
	} else {
	    croak "$!: $self->{history_file}";
	}
    }
    if ($self->{resources_file}) {
	my $resources = $self->{resources};
	if (open TMP,">$self->{resources_file}") {
	    for my $key (keys %$resources) {
		print TMP "$key\n";
		for my $value (keys %{$resources->{$key}}) {
		    print TMP "  $value\n";
		}
	    }
	    close TMP;
	} else {
	    croak "$!: $self->{resources_file}";
	}
    }
    $self->{vector_dialogs}->close;
    $self->{raster_dialogs}->close;
    delete $self->{vector_dialogs};
    delete $self->{raster_dialogs};
    delete $self->{statusbar};
    delete $self->{toolbar};
    delete $self->{model};
    $self->{entry}->destroy;
    delete $self->{entry};
    $self->{tree_view}->destroy;
    delete $self->{tree_view};
    $self->{overlay}->close;
    $self->{overlay}->destroy;
    delete $self->{overlay};
    Gtk2::Ex::Geo::DialogMaster::close($self);
}

sub get_dialog {
    my($self, $dialog_name) = @_;
    my $d = $self->SUPER::get_dialog($dialog_name);
    $d = $self->{raster_dialogs}->get_dialog($dialog_name) unless $d;
    $d = $self->{vector_dialogs}->get_dialog($dialog_name) unless $d;
    return $d;
}

sub layer_menu {
    my($tv,$event,$self) = @_;

    my @res = $self->{tree_view}->get_path_at_pos($event->x,$event->y);
    return unless defined $res[0];

    my $layer = $self->{overlay}->get_layer_by_index($res[0]->to_string); 
    return unless $layer;

    my $column = $res[1]->get_title;
    
    if ($event->button == 3) {

	my $menu = Gtk2::Menu->new;

	my $hide = $layer->visible() ? '_Hide' : '_Show';
	
	my @items = ('_Zoom to','_Up','_Down',$hide,'_Remove');
	my @layer_items = $layer->menu_items;
	if (@layer_items) {
	    push @items, ('',@layer_items);
	}
	push @items, ('','_Symbol...','_Colors...','_Labeling...','_Inspect...','_Properties...');
	
	for (my $i = 0 ; $i < @items ; $i++) {
	    if ($items[$i] eq '') {
		my $item = Gtk2::SeparatorMenuItem->new();
		$item->show;
		$menu->append ($item);
		next;
	    }
	    my $item = Gtk2::MenuItem->new ($items[$i]);
	    $item->show;
	    $menu->append ($item);
	    $item->{index} = $i;
	    $item->{text} = $items[$i];
	    $item->signal_connect(activate => \&layer_menu_item, [$self, $items[$i]]);
	}
	$menu->popup(undef, undef, undef, undef, $event->button, $event->time);

    } elsif ($column eq '?') {

	$layer->visible(!$layer->visible());
	$self->update;
	$self->{overlay}->render;

    }

    return 0;
}

sub layer_menu_item {
    my ($item, $info) = @_;
    my $self = shift @$info;
    $_ = shift @$info;
    my $layer = $self->get_selected_layer();

    return if $layer->menu_action($_, $self);

    $_ =~ s/_//g;
  SWITCH: {
      if (/Zoom to/) {
	  $self->{overlay}->zoom_to($layer);
	  last SWITCH; 
      }
      if (/Up/) {
	  $self->move_up();
	  last SWITCH; 
      }
      if (/Down/) {
	  $self->move_down();
	  last SWITCH; 
      }
      if (/(Show)|(Hide)/) {
	  $layer->visible(!$layer->visible());
	  $self->update;
	  $self->{overlay}->render;
	  last SWITCH;
      }
      if (/Properties/) {
	  $layer->properties_dialog($self);
	  #$self->update();
	  #$self->{overlay}->render;
	  last SWITCH; 
      }
      if (/Symbol/) {
	  $layer->symbols_dialog($self);
	  last SWITCH; 
      }
      if (/Colors/) {
	  $layer->colors_dialog($self);
	  last SWITCH; 
      }
      if (/Labeling/) {
	  $layer->labels_dialog($self);
	  last SWITCH;
      }
      if (/Inspect/) {
	  $self->inspect($layer, $layer->name);
	  last SWITCH; 
      }
      if (/Remove/) {
	  $self->delete_selected(); 
	  last SWITCH; 
      }
  }
    
}

=pod

=head2 set_event_handler($event_handler,$user_param);

$event_handler is a user subroutine for handling events happening in
the overlay widget, it is called with parameters ($user_param, $event,
@xy);

=cut

sub set_event_handler {
    my($self,$event_handler,$user_param) = @_;
    $self->{event_handler} = $event_handler;
    $self->{event_handler_user_param} = $user_param;
}

sub default_event_handler {
    my ($self, $event, $x1, $y1, $x0, $y0) = @_;

    return unless defined $x1;

    my $layer = $self->get_selected_layer();
    my $mode;
    ($mode) = $self->{overlay}->{rubberbanding} =~ /^(\w+)/;
    $mode = '' unless defined $mode;

    my $location = sprintf("(x,y) = (%.4f, %.4f)",$x1,$y1);
    my $value = '';
    if ($layer and ref($layer) =~ /Raster/) {
	my @ij = $layer->w2g($x1,$y1);
	$location .= sprintf(", (i,j) = (%i, %i)",@ij);
	$value = $layer->point($x1,$y1);
	if (defined $value and $value ne 'nodata' and $layer->{INFO}) {
	    $value = $layer->{TABLE}->{DATA}->[$value]->[$layer->{INFO}-1];
	}
    }

    $self->{statusbar}->pop(0);

    $value = '' unless defined $value;

    # additional info, based on mode
    my $rubberband = $self->{overlay}->rubberband_value();
	
    $rubberband = '' unless defined $rubberband;

    $self->{statusbar}->push(0, sprintf("$mode $location $value $rubberband"));
}

=pod

=head2 set_draw_on($draw_on,$user_param);

$draw_on is a user subroutine for drawing on the overlay widget once
the overlay widget has created it, it is called with parameters
($user_param, $pixmap);

=cut

sub set_draw_on {
    my($self,$draw_on,$user_param) = @_;
    $self->{draw_on} = $draw_on;
    $self->{draw_on_user_param} = $user_param;
}

=pod

=head2 toolbar

returns a Gtk2::Toolbar, which is tied to attribute {toolbar} when a
new Gtk2::Ex::Geo::Glue object is created, a subroutine is connected
to each toolbar button

=cut

sub toolbar {
    my($self) = @_;

    my $toolbar = Gtk2::Toolbar->new ();
    
    my %tips = ('Open raster layer' => 'Add a new raster layer.',
		'Open vector layer' => 'Add a new vector layer.',
		'Zoom to all' => 'Zoom to all layers.',
		'Save all' => 'Save all layers.',
		'Select' => 'Set select mode.',
		'Edit' => 'Show the vertices or the objects.',
		'Move' => 'Set the move mode (move selected vertices).',
		'Shell' => 'Go back to Perl shell in the terminal.'
		);

    for (reverse('Open raster layer',
		 'Open vector layer',
		 'Zoom to all',
		 'Save all',
#		 'Select',
#		 'Edit',
#		 'Move',
#		 'Shell'
		 )) {

	my $b = Gtk2::ToolButton->new(undef,$_);

	my $tooltips = Gtk2::Tooltips->new;
	$b->set_tooltip($tooltips,$tips{$_},'');
	$tooltips->set_tip($b,$tips{$_});
	$tooltips->enable;

	$toolbar->insert($b,0);
	my $sub;
      SWITCH: {
	  if (/raster/) { $sub = 
			      sub {
				  my(undef, $self) = @_;
				  return unless $self->add_raster();
				  $self->{tree_view}->set_cursor(Gtk2::TreePath->new(0));
			      }; last SWITCH; }
	  if (/vector/) { $sub = 
			      sub {
				  my(undef, $self) = @_;
				  $self->{history}->enter(''); # ogr_open dialog uses the same history
				  $self->{vector_dialogs}->ogr_open($self);
			      }; last SWITCH; }
	  if (/^Zoom to all/) { $sub = 
				    sub {
					my(undef, $self) = @_;
					$self->{overlay}->zoom_to_all(); 
				    }; last SWITCH; }
	  if (/^Save all/) { $sub = 
				 sub {
				     my(undef, $self) = @_;
				     $self->save_all_layers(); 
				 }; last SWITCH; }
	  if (/^Select/) { $sub = 
			       sub {
				   my(undef, $self) = @_;
				   $self->{overlay}->{rubberbanding} = 'select rect';
				   $self->{overlay}->event_handler();
			       }; last SWITCH; }
	  if (/^Edit/) { $sub = 
			     sub { 
				 my(undef, $self) = @_;
				 my $layer = $self->get_selected_layer();
				 if (ref($layer) eq 'Geo::Shapelib' or 
				     ref($layer) eq 'Geo::Vector') {
				     $layer->{ShowPoints} = $layer->{ShowPoints} ? 0 : 1;
				     $self->{overlay}->render();
				     $self->{overlay}->event_handler();
				 }
			     }; last SWITCH; }
	  if (/^Move/) { $sub = 
			     sub {
				 my(undef, $self) = @_;
				 $self->{overlay}->{rubberbanding} = 'move line';
				 $self->{overlay}->event_handler();
			     }; last SWITCH; }
	  
	  if (/^Shell/) { $sub = 
			      sub {
				  my(undef, $self) = @_;
				  $self->shell();
			      }; last SWITCH; }
      }
	$b->signal_connect ("clicked", $sub, $self);
    }
    return $toolbar;
}

sub inspect {
    my($self, $data, $name) = @_;

    $name = 'unknown variable' unless $name;

    $data = \$data unless ref $data;

    my $treedumper = Gtk2::Ex::Geo::TreeDumper->new #Data::TreeDumper::Renderer::GTK->new
	(data => $data,
	 title => $name,
	 dumper_setup => {});

    $treedumper->modify_font(Gtk2::Pango::FontDescription->from_string ('monospace'));
    $treedumper->collapse_all;

    my $scroller = $self->{glade}->get_widget('scrolledwindow2');
    $scroller->remove($self->{treedumper}) if $self->{treedumper};

    $self->{treedumper} = $treedumper;
    $scroller->add($treedumper);

    $self->open_dialog('dialog1', $name);
}

=pod

=head2 add_raster

calls Gtk2::FileChooserDialog and if a file of known type is selected,
opens it and adds it by calling add_layer

=cut

sub save_all_layers {
    my($self) = @_;

    $self->message('No layers to save.'), return
	unless $self->{overlay}->{layers} and @{$self->{overlay}->{layers}};

    my $file_chooser =
	Gtk2::FileChooserDialog->new ("Save all rasters into folder",
				      undef, 'select_folder',
				      'gtk-cancel' => 'cancel',
				      'gtk-ok' => 'ok');

    my $folder = $file_chooser->get_current_folder();
    $folder = $self->{folder} if $self->{folder};
    $file_chooser->set_current_folder($folder);
    my $uri;
    if ($file_chooser->run eq 'ok') {
	$uri = $file_chooser->get_uri;
	$self->{folder} = $file_chooser->get_current_folder();
    }
    $file_chooser->destroy;

    if ($uri) {

	$uri =~ s/^file:\/\///;	

	for my $layer (@{$self->{overlay}->{layers}}) {
	    
	    my $filename = File::Spec->catfile($uri, $layer->name);

	    my $save = 1;
	    if ($layer->exists($filename)) {
		my $dialog = Gtk2::MessageDialog->new(undef,'destroy-with-parent',
						      'question',
						      'yes_no',
						      "Overwrite existing $filename?");
		my $ret = $dialog->run;
		$save = 0 if $ret eq 'no';
		$dialog->destroy;
	    }
	    $layer->save($filename) if $save;
	}
    }
}

sub save_raster {
    my($self, $gd) = @_;
    my $file_chooser =
	Gtk2::FileChooserDialog->new ("Save raster '".$gd->name."' as:",
				      undef, 'save',
				      'gtk-cancel' => 'cancel',
				      'gtk-ok' => 'ok');

    my $folder = $file_chooser->get_current_folder();
    $folder = $self->{folder} if $self->{folder};
    $file_chooser->set_current_folder($folder);
    $file_chooser->set_current_name($gd->name);
    my $filename;
    if ($file_chooser->run eq 'ok') {
	$filename = $file_chooser->get_filename;
	$self->{folder} = $file_chooser->get_current_folder();
    }
    $file_chooser->destroy;

    if ($filename) {
	my $save = 1;
	if ($gd->exists($filename)) {
	    my $dialog = Gtk2::MessageDialog->new(undef,'destroy-with-parent',
						  'question',
						  'yes_no',
						  "Overwrite existing $filename?");
	    my $ret = $dialog->run;
	    $save = 0 if $ret eq 'no';
	    $dialog->destroy;
	}
	$gd->save($filename) if $save;
    }
}

sub add_raster {
    my($self) = @_;

    my $file_chooser =
	Gtk2::FileChooserDialog->new ('Select a raster file',
				      undef, 'open',
				      'gtk-cancel' => 'cancel',
				      'gtk-ok' => 'ok');

    $file_chooser->set_select_multiple(1);

    my $filename;
    my @filenames;

    $file_chooser->set_current_folder($self->{folder}) if $self->{folder};
    
    if ($file_chooser->run eq 'ok') {
	@filenames = $file_chooser->get_filenames;
    }

    $self->{folder} = $file_chooser->get_current_folder();
    
    $file_chooser->destroy;

    return unless @filenames;

    for $filename (@filenames) {
	my $dataset = Geo::GDAL::Open($filename);
	croak "$filename is not recognized by GDAL" unless $dataset;
	my $bands = $dataset->{RasterCount};
	
	for my $band (1..$bands) {
	    
	    my $layer = Gtk2::Ex::Geo::Raster->new(filename => $filename, band => $band);
	    
	    my $b = $dataset->GetRasterBand($band);
	    my $ci = $b->GetRasterColorInterpretation;
	    if ($ci == $Geo::GDAL::Const::GCI_RedBand) {
		$layer->palette_type('Red channel');
		$layer->color_scale($b->GetMinimum, $b->GetMaximum);
	    } elsif ($ci == $Geo::GDAL::Const::GCI_GreenBand) {
		$layer->palette_type('Green channel');
		$layer->color_scale($b->GetMinimum, $b->GetMaximum);
	    } elsif ($ci == $Geo::GDAL::Const::GCI_BlueBand) {
		$layer->palette_type('Blue channel');
		$layer->color_scale($b->GetMinimum, $b->GetMaximum);
	    }
	    
	    my $name = fileparse($filename);
	    $name =~ s/\.\w+$//;
	    $name .= "_$band" if $bands > 1;
	    $self->add_layer($layer, $name, 1);
	    $self->{overlay}->render;
	}
    }
    
    return 1;
}

sub add_vector {
    my($self,$datasource,$layer_name,$layer_name_wish,$sql,$update) = @_;

    return unless $layer_name;

    if (ref $layer_name) {
	for my $name (@$layer_name) {
	    my $layer;
	    eval {
		$layer = Gtk2::Ex::Geo::Vector->new( datasource=>$datasource, layer=>$name, sql=>$sql, update=>$update );
	    };
	    if ($@) {
		my $err = $@;
		if ($err) {
		    $err =~ s/\n/ /g;
		    $err =~ s/\s+$//;
		    $err =~ s/\s+/ /g;
		    $err =~ s/^\s+$//;
		} else {
		    $err = "datasource=$datasource, layer=$name, sql=$sql, update=$update";
		}
		croak("Could not open a layer: $err");
		return;
	    }

	    $self->add_layer($layer, $name, 1);	    
	}
	$self->{overlay}->render;
	return 1;
    }

    $layer_name_wish = $layer_name unless $layer_name_wish;

    my $layer;

    eval {
	$layer = Gtk2::Ex::Geo::Vector->new( datasource=>$datasource, layer=>$layer_name, sql=>$sql, update=>$update );
    };
    if ($@) {
	my $err = $@;
	if ($err) {
	    $err =~ s/\n/ /g;
	    $err =~ s/\s+$//;
	    $err =~ s/\s+/ /g;
	    $err =~ s/^\s+$//;
	} else {
	    $err = "datasource=$datasource, layer=$layer_name, sql=$sql, update=$update";
	}
	croak("Could not open a layer: $err");
	return;
    }

    $self->add_layer($layer, $layer_name_wish, 1);
    $self->{overlay}->render;

    $self->{tree_view}->set_cursor(Gtk2::TreePath->new(0));

    return 1;
}

## @method p(scalar something, hash options)
# Attempts to print data from (references to) hashes and arrays nicely.
# The named parameter 'file' can be used to print to a file.
# The named parameter 'column' can be used to print only that column from
# a two-dimensional array. The column 1 is the first column.
# @param something reference to a hash or an array
# @param options a list of named parameters and key=>value pairs
sub p {
    my($self,$this,%o) = @_;
    $self->output($o{file}) if $o{file};
    if (ref($this) eq 'HASH') {
	my @keys = keys %{$this};
	return unless @keys;
	if ($keys[0] =~ /^[-+\d.]+$/) {
	    foreach (sort {$a<=>$b} @keys) {
		my $v = $$this{$_};
		if (ref($v) eq 'ARRAY') {
		    print "$_ @{$v}\n";
		} else {
		    print "$_ $v\n";
		}
	    }
	} else {
	    foreach (sort @keys) {
		my $v = $$this{$_};
		if (ref($v) eq 'ARRAY') {
		    print "$_ @{$v}\n";
		} else {
		    print "$_ $v\n";
		}
	    }
	}
    } elsif (ref($this) eq 'ARRAY') {
	my $column = defined $o{column} ? $o{column} : 0;
	foreach (@{$this}) {
	    if (ref($_) eq 'ARRAY') {
		print $column ? "$_->[$column-1]\n" : "@$_\n";
	    } else {
		print "$_\n";
	    }
	}
    } else {
	print "$this\n";
    }
    $self->output() if $o{file};
}

# there are one or many datasets in this
sub get_plot_datasets {
    my($this) = @_;
    if (ref($this)) {
	if (ref($this) eq 'ARRAY') {
	    my $index = 0;
	    my @datasets;
	    # elements of this are either well known objects, type, or first element of values
	    while ($index <= $#$this) {
		if (ref($this->[$index]) eq 'HASH') {
		    my @data;
		    for my $x (sort {$a<=>$b} keys %$this) {
			push @data, [$x, $this->{$x}];
		    }
		    push @datasets, ['point_series', \@data];
		    $index++;
		} elsif (ref($this->[$index])) {
		    croak "expected a well known object or dataset type specifier at $index\n";
		} else {
		    if ($this->[$index] =~ /^p/) { # point dataset or -sets
			$index++;
			if (ref($this->[$index][0][0])) {
			    for my $s (@{$this->[$index]}) {
				push @datasets, ['point_series', $s];
			    }
			} else {
			    push @datasets, ['point_series', $this->[$index]];
			}
			$index++;
		    } elsif ($this->[$index] =~ /^v/) { # value dataset or -sets
			$index++;
			if (ref($this->[$index][0])) {
			    for my $s (@{$this->[$index]}) {
				push @datasets, ['value_series', $s];
			    }
			} else {
			    push @datasets, ['value_series', $this->[$index]];
			}
			$index++;
		    } elsif ($this->[$index] =~ /^d/) { # datafile
			$index++;
			push @datasets, ['datafile', $this->[$index++]];
		    } elsif ($this->[$index] =~ /^f/) { # function
			$index++;
			push @datasets, ['function', $this->[$index++]];
		    } else {
			return [['value_series', $this]];
		    }
		}
	    }
	    return \@datasets;
	} elsif (ref($this) eq 'HASH') {
	    my @data;
	    for my $x (sort {$a<=>$b} keys %$this) {
		push @data, [$x, $this->{$x}];
	    }
	    return [['point_series', \@data]];
	} else {
	    croak "don't know how to plot a " . ref($this) . "\n";
	}
    } elsif (-e $this) {
	return [['datafile', '"'.$this.'"']];
    } else {
	return [['function', $this]];
    }
}

## @method plot(scalar something, hash options)
# An interface to gnuplot. 

# The gnuplot plot parameters 'title', 'with' (default "lines"),
# 'xrange', 'yrange', 'using' (default "using 1:2"), and 'other' can
# be defined via named parameters.  plot() uses p() to print to the
# file 'plot_data' or to one specified with named parameter
# 'datafile'.  The output is to a gnuplot window or to a PNG image
# file if named parameter 'image_file' is given.

# the named parameter 'column' is fed through to p().
# @param something either a filename or a reference to a hash or an array
# @param options a list of named parameters and key=>value pairs for gnuplot or p
sub plot {
    my($self, $this, %o) = @_;
    my $gnuplot = $Config::Config{'osname'} eq 'MSWin32' ? 'pgnuplot' : 'gnuplot';
    open GNUPLOT, "| $gnuplot" or croak "can't open gnuplot: $!\n";
    my $fh = select(GNUPLOT); $| = 1;
    my $datafile = $o{datafile} || 'plot_data';
    if ($o{image_file}) {
	gnuplot("set terminal png");
	gnuplot("set output \"$o{file}.png\"");
    }
    $o{with} = 'lines' unless $o{with};
    my $xrange = $o{xrange} ? $o{xrange} : '';
    my $yrange = $o{yrange} ? $o{yrange} : '';
    my $other = $o{other} ? ', ' . $o{other} : '';

    gnuplot("set xdata");
    gnuplot("set format x");

    # an array of [type, dataset]
    my $datasets = get_plot_datasets($this);

    my($minx, $maxx, $miny, $maxy);
    my $range = 0;
    my @title;
    my @what;
    my @with;
    my @index;
    my @using;
    my $index = 0;
    my $plot_index = 0;

    for (@$datasets) {
	my($type, $dataset) = @$_;
	#print STDERR "type=$type, dataset=$dataset\n";
	if (defined $o{title}) {
	    my $t = ref($o{title}) ? $o{title}->[$index] : $o{title};
	    $title[$index] = "title \"$t\"";
	} else {
	    if ($type =~ /^f/) {
		$title[$index] = "title \"$dataset\"";
	    } elsif ($type =~ /^d/) {
		$title[$index] = "title $dataset";
	    } else {
		$title[$index] = "title \"$index\"";
	    }
	}
	$with[$index] = ref($o{with}) ? $o{with}->[$index] : $o{with};
	if (defined $o{using}) {
	    my $u = ref($o{using}) ? $o{using}->[$index] : $o{using};
	    $using[$index] = "using \"$u\"";
	} else {
	    $using[$index] = '';
	}
	if ($type =~ /^p/) {
	    $using[$index] = 'using 1:2' unless $using[$index];
	    for (@$dataset) {
		$minx = $_->[0] if !defined($minx) or $_->[0] < $minx;
		$maxx = $_->[0] if !defined($maxx) or $_->[0] > $maxx;
		$miny = $_->[1] if !defined($miny) or $_->[1] < $miny;
		$maxy = $_->[1] if !defined($maxy) or $_->[1] > $maxy;
	    }
	} elsif ($type =~ /^v/) {
	    for (@$dataset) {
		$miny = $_ if !defined($miny) or $_ < $miny;
		$maxy = $_ if !defined($maxy) or $_ > $maxy;
	    }
	}
	if ($type =~ /^p/ or $type =~ /^v/) {
	    $self->output($datafile, $index ? (gnuplot_add=>1) : (0=>0));
	    $self->p($dataset, column=>$o{column});
	    $self->output;
	    $what[$index] = "\"$datafile\"";
	    $index[$index] = "index $plot_index";
	    $plot_index++;
	} else {
	    $what[$index] = $dataset;
	    $index[$index] = '';
	}
	if ($with[$index] eq 'impulses') {
	    $range = 1;
	}
	$index++;
    }

    if ($range) {
	$xrange = "[$minx:$maxx]";
    }

    my $plot = "plot $xrange$yrange $what[0] $index[0] $using[0] $title[0] with $with[0]";
    for $index (1..$#$datasets) {
	$plot .= ", $what[$index] $index[$index] $using[$index] $title[$index] with $with[$index]";
    }
    gnuplot($plot . $other);

    if ($o{file}) {
	gnuplot("set terminal x11");
	gnuplot("set output");
    }

    select($fh);
}

sub gnuplot {
    my $line = shift;
    $line = '' unless $line;
#    print "$line\n" if $_options{debug};
    print GNUPLOT "$line\n";
}

=pod

=head2 clip_selected

returns the selected (or visible) piece of a selected raster

todo: same for vector layers

=cut

sub clip_selected {
    my($self) = @_;
    my $gd = $self->selected_layer();
    return unless $gd;
    return unless ref($gd) =~ /Raster/;
    my @clip = $self->{overlay}->get_focus;
    @clip = $gd->wa2ga(@clip);
    return $gd->clip(@clip);
}

sub set_layer {
    my($self, $layer) = @_;
    my($type, $colors, $visible, $alpha);

    $type = '';
    $alpha = $layer->alpha();
    $alpha = 'Layer' if ref($alpha);

    $type = $layer->type;

    $visible = $layer->visible ? 'X' : ' ';

    $self->{model}->set ($layer->{iterator},
			 0, $layer->name(),
			 1, $type,
			 2, $visible,
			 3, $alpha,
			 );
}

=pod

=head2 add_layer($layer,$name,$do_not_zoom_to);

adds $layer with $name to overlay and model

the default behavior is to zoom to the new layer

=cut

sub add_layer {
    my($self, $layer, $name, $do_not_zoom_to) = @_;
    return unless $layer;
    croak "can add only Gtk2::Ex::Geo::Layer objects" unless isa($layer, 'Gtk2::Ex::Geo::Layer');

    my $i = $self->{overlay}->index_of_layer($name);
    croak "layer with name $name already exists" if defined $i;

    $layer->defaults(name => $name);
    $layer->{iterator} = $self->{model}->insert (undef, 0);
 
    $self->set_layer($layer);
    $self->{overlay}->add_layer($layer,$do_not_zoom_to);
}

=pod

=head2 get_focal($name)

Returns a selected (or visible) part of a raster layer by its name.

todo: same for vector layers

=cut

sub get_focal {
    my($self,$name) = @_;
    my $gd = $self->{overlay}->get_layer_by_name($name);
    if ($gd and ref($gd) =~ /Raster/) {
	my @clip = $self->{overlay}->get_focus;
	@clip = $gd->wa2ga(@clip);
	# do not expand the view
	$clip[2]--; 
	$clip[3]--;
	return $gd->clip(@clip);
    }
}

=pod

=head2 update

updates the tree_view

=cut

sub update {
    my($self) = @_;
    for my $layer (@{$self->{overlay}->{layers}}) {
	$self->set_layer($layer);
    }
}

sub swap {
    my($array,$i1,$i2) = @_;
    my $e1 = $array->[$i1];
    my $e2 = $array->[$i2];
    $array->[$i1] = $e2;
    $array->[$i2] = $e1;
    return ($e1,$e2);
}

=pod

=head2 move_down

moves the selected layer down in the overlay

=cut

sub move_down {
    my($self) = @_;

    my ($path, $focus_column) = $self->{tree_view}->get_cursor;
    return unless $path;
    my $index = $path->to_string;
    my $n = $#{$self->{overlay}->{layers}};
    if ($index < $n) {
	my($layer1,$layer2) = swap($self->{overlay}->{layers},$n-$index,$n-$index-1);
	$self->{model}->move_after($layer1->{iterator},$layer2->{iterator});
	$self->{overlay}->render;
    }

}

=pod

=head2 move_up

moves the selected layer up in the overlay

=cut

sub move_up {
    my($self) = @_;

    my ($path, $focus_column) = $self->{tree_view}->get_cursor;
    return unless $path;
    my $index = $path->to_string;
    my $n = $#{$self->{overlay}->{layers}};
    if ($index > 0) {
	my($layer1,$layer2) = swap($self->{overlay}->{layers},$n-$index,$n-$index+1);
	$self->{model}->move_before($layer1->{iterator},$layer2->{iterator});
	$self->{overlay}->render;
    }

}

=pod

=head2 delete_selected

removes the selected layer from the overlay

=cut

sub remove_layer {
    my($self, $name) = @_;
    my $layer = $self->{overlay}->get_layer_by_name($name);
    return unless $layer;
    $self->{model}->remove($layer->{iterator});
    $self->{overlay}->remove_layer_by_name($name);
    $self->{overlay}->render;
}

sub delete_selected {
    my($self) = @_;
    my ($path, $focus_column) = $self->{tree_view}->get_cursor;
    return unless $path;
    my $index = $path->to_string;
    my $n = $#{$self->{overlay}->{layers}};
    if ($index >= 0 and $index <= $n) {
	my($layer) = splice(@{$self->{overlay}->{layers}},$n-$index,1);
	$self->{model}->remove($layer->{iterator});
	if ($n > 0) {
	    $index-- if $index == $n;
	    $self->{tree_view}->set_cursor(Gtk2::TreePath->new($index));
	}
	$layer->destroy_dialogs;
	$self->{overlay}->render;
    }
}

=pod

=head2 get_selected_layer

returns the selected layer

=cut

sub get_selected_layer {
    my($self) = @_;
    my($path, $focus_column) = $self->{tree_view}->get_cursor;
    return unless $path;
    my $index = $path->to_string;
    return $self->{overlay}->selected_layer($index);
}

sub select_layer {
    my($self, $name) = @_;
    my $index = $self->{overlay}->index_of_layer($name);
    if (defined $index) {
	$self->{tree_view}->set_cursor(Gtk2::TreePath->new($index));
    }
}

=pod

=head2 event_handler

=cut

sub event_handler {
    my ($self,$event,@points) = @_;

    # select & move vertices is handled here

    if ($self->{overlay}->{selection}) {

	my $layer = $self->get_selected_layer();

	if (ref($layer) eq 'Geo::Shapelib') {

	    if ($self->{overlay}->{rubberbanding} =~ /select/ and $layer->{Rtree}) {

		my @selection = @{$self->{overlay}->{selection}};

		my @shapes;

		$layer->{Rtree}->query_completely_within_rect(@selection,\@shapes);
		print "you selected shapes: @shapes\n";

		@shapes = ();
		$layer->{Rtree}->query_partly_within_rect(@selection,\@shapes);
		print "shapes: @shapes overlap with the selection\n";
		
		# undo all

		$layer->clear_selections();
		
		# here find the vertices in the selection

		for my $shape (@shapes) {
		    my $vertices = $layer->select_vertices($shape,@selection);
		    my $n = @$vertices;
		    print "you selected $n vertices from shape $shape\n";
		}
		
	    } elsif ($self->{overlay}->{rubberbanding} =~ /move/) {

		my($fromx,$fromy,$dx,$dy) = @{$self->{overlay}->{selection}};

		$layer->move_selected_vertices($dx,$dy);

	    }

	    $self->{overlay}->render();

	}
	
    }

    return unless $self->{event_handler};
    $self->{event_handler}->($self->{event_handler_user_param},$event,@points);
}

sub draw_on {
    my($self,$pixmap) = @_;
    $self->{draw_on}->($self->{draw_on_user_param},$pixmap) if $self->{draw_on};
}


=pod

=head2 eval_entry and shell

eval_entry is called when something happens in the entry, arrow up and
down retrieve entries from the history

the entry is given to Perl eval function after 

1) the variable names are inspected and found layer names are replaced
with pointers to real layers

2) keyword "focal:" in the beginning of an entry is removed and all
references to layers are replaced with clipped versions

shell suspends the main Gtk2 window and gives the focus to the
text-based terminal with a plain Perl eval loop

=cut

sub eval_entry {
    my($entry,$event,$self) = @_;
    my $key = $event->keyval;
    
    my $text = $entry->get_text;
    $self->{history}->editing($text);

    if ($text ne '' and $key == $Gtk2::Gdk::Keysyms{Return}) {

	$self->{history}->enter();
	$entry->set_text('');

	my $focal = 0; # default is global
	if ($text =~ /^focal:\s*/) {
	    $text =~ s/^focal:\s*//;
	    $focal = 1;
	}
	for my $sub ('inspect','p','plot') {
	    $text =~ s/^$sub/\$self\-\>$sub/ if $text =~ /^$sub\(/;
	}
	my @g = $text =~ /\$(\w+)/g;
	my @_gd;
	for my $i (0..$#g) {
	    $_gd[$i] = $focal ? $self->get_focal($g[$i]) : $self->{overlay}->get_layer_by_name($g[$i]);
	    next unless $_gd[$i];
	    $text =~ s/\$$g[$i]\b/\$_gd[$i]/;
	}
	{
	    no strict;
	    eval $text;
	    croak "$text\n$@" if $@;
	}
	for my $i (0..$#g) {
	    if ($self->{overlay}->get_layer_by_name($g[$i])) {
		$_gd[$i]->value_range() if ref($_gd[$i]) =~ /Raster/;
	    } else {
		eval "\$self->add_layer(\$$g[$i],'$g[$i]',1) if isa(\$$g[$i], 'Gtk2::Ex::Geo::Layer');"
		    if $g[$i] and $g[$i] ne 'self';
	    }
	}
	undef @_gd;
	$self->update();
	$self->{overlay}->render;
	return 1;
    } elsif ($key == $Gtk2::Gdk::Keysyms{Up}) {
	$entry->set_text($self->{history}->arrow_up);
	return 1;
    } elsif ($key == $Gtk2::Gdk::Keysyms{Down}) {
	$entry->set_text($self->{history}->arrow_down);
	return 1;
    }
}

sub min {
    $_[0] > $_[1] ? $_[1] : $_[0];
}

sub max {
    $_[0] > $_[1] ? $_[0] : $_[1];
}

sub shell {
    my($self) = @_;
    my $term = new Term::ReadLine '';
    my $hfile = "$ENV{HOME}/.rash_history";
    $term->ReadHistory($hfile);
    while ( defined ($_ = $term->readline('>')) ) {
	chomp;
	my $input = $_;
	if (/^\?$/ or /^help$/i) {
	    system "perldoc $0";
	} elsif (/^\? Raster$/ or /^help Raster$/i) {
	    system "man Geo::Raster";
	} elsif (/^\!(.*)/) {
	    system $1;
	} else {
	    eval;
	    print $@;
	}
	Gtk2->main_iteration_do(0); # does not do the trick of window updating
    }
    print "\n";
    $term->WriteHistory($hfile);
    $self->update();
    $self->{overlay}->render;
}

sub output {
    my($self,$fn,%o) = @_;
    if ($fn and exists $o{gnuplot_add}) {
	open OUTPUT,">>$fn" or croak("can't open $fn: $!\n");
	print OUTPUT "\n\n";
	select OUTPUT;
    } elsif ($fn) {
	open OUTPUT, ">$fn" or croak "can't open $fn: $!\n";
	select OUTPUT;
    } else {
	CORE::close(OUTPUT);
	select STDOUT;
    }
}

package Gtk2::Ex::Geo::History;

sub new {
    my ($class, $history) = @_;
    push @$history,'' unless $history->[$#$history] eq '';
    my $self = { index => $#$history,
		 history => $history,
		 edit_index => -1,
		 edit_text => '',
	     };
    bless($self, $class); 
}

sub arrow_up {
    my $self = shift;
    if ($self->{edit_index} >= 0) {
	$self->{history}->[$self->{edit_index}] = $self->{edit_text};
    }
    $self->{index} = max(0, $self->{index}-1);
    return $self->{edit_text} if $self->{edit_index} == $self->{index};
    return $self->{history}->[$self->{index}];
}

sub arrow_down {
    my $self = shift;
    if ($self->{edit_index} >= 0) {
	$self->{history}->[$self->{edit_index}] = $self->{edit_text};
    }
    $self->{index} = min($#{$self->{history}}, $self->{index}+1);
    return $self->{edit_text} if $self->{edit_index} == $self->{index};
    return $self->{history}->[$self->{index}];
}

sub editing {
    my ($self, $text) = @_;
    $self->{edit_index} = $self->{index};
    $self->{edit_text} = $text;
}

sub enter {
    my ($self, $text) = @_;
    $self->{edit_text} = $text if defined $text;
    my $history = $self->{history};
    if ($#$history >= 0) {
	unless ($#$history > 0 and $history->[$#$history-1] eq $self->{edit_text}) {
	    $history->[$#$history] = $self->{edit_text};
	    push @$history,'' unless $self->{edit_text} eq '';
	}
	$self->{index} = $#$history;
	$self->{edit_index} = -1;
	$self->{edit_text} = '';
    }
}

sub min {
    $_[0] > $_[1] ? $_[1] : $_[0];
}

sub max {
    $_[0] > $_[1] ? $_[0] : $_[1];
}

=pod

=head1 SEE ALSO

Gtk2::Ex::Geo

=head1 AUTHOR

Ari Jolma, E<lt>ajolma at tkk.fiE<gt>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2006 by Ari Jolma

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.5 or,
at your option, any later version of Perl 5 you may have available.

=cut

1;
__DATA__

